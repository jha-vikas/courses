## Objects

* Object: collection of data and associated behaviours
* Object oriented means functionally directed towards modeling objects.
* Object-oriented analysis (OOA): process of looking at a problem, system, or task and identifying the objects and interactions between those objects. Object oriented design is the process of converting these requirements into an implementation specification. Object oriented programming is the process of converting the defined design into a working program that does exactly what was intended.
* Classes describe objects.
* Objects are instances of classes that can be associated with each other. An object instance is a specific object with its own set of data and behaviours.
* Data typically represents individual characteristics of a certain object. A class can define specific set of characteristics that are shared by all objects of that class. __Attributes__ are referred to as members or properties. Depending how detailed the design needs are, the type of each attribute can be specified. Eg: Weight of an apple of apple class.
* Behaviours are actions that can occur on an object. Behaviours that can be performed on a specific class of objects are called methods. At programming level, methods are like functions, but they have access to all the data associated with this object. Like functions, methods can also accept parameters and return values. Parameters/arguments to a method are a list of objects that need to be passed into the method that is being called.
* Adding models and methods to individual objects allows us to create a system of interacting objects.

## Hiding details & creating public interface

* The key purpose of modeling an object in OOD is to determine the public interface of that object, which is a collection of attributes and methods that other object can use to interact with that object.
* The process of hiding the implementation, or functional details, internal working of an object is called information hiding. Encapsulation is a more all-encompassing term.
* Abstraction: dealing with the level of detail that is most appropriate to a given task. It is the process of extracting a public interface from the inner details. It is the process of encapsulating information with separate public and private interfaces. The private interfaces can be subject to information hiding.
* Composition: Act of collecting several objects together to create a new one. Aggregation is similar to composition, with difference being that the aggregate objects can exist independently.
* Inheritance: Inheritance is like family tree. An offspring object(sub-class) inherits properties from parent object(parent class). The properties, which include the behaviours can be modified/over-ridden.
* Polymorphism: ability to treat a class differently depending on which subclass is implemented. Sort of polymorphism in Python is referred as "duck typing".
* Multiple inheritance: Subclass can inherit functionality from multiple parent classes.

## Modules and packages

* Modules are python files. The single file in a program is a module.
* Package is a collection of modules in a folder. The name of the package is the name of the folder. While importing modules or classes between packages, we have to be cautious about the syntax. There are two ways to importing modules: absolute imports and relative imports.
* In absolute import, we specify the full path. In relative import, we specify the location relative to the current location. "." means to look for the module in the current directory. Eg: `from .database import Database`. ".." means look for the module in the parent directory. Eg: `from ..database import Database`. We can use more periods to go further up the hierarchy. We can also go down one side and back up the other. Eg: `from ..contact.email import send_mail`. It uses two periods to say, *the parent of the payments(current) package*, and then uses the normal `package.module` syntax to go back up into the contact package.
* We can also import code directly from packages, as opposed to just modules inside the packages. The `__init__.py` defines a directory as a package. This file can contain any variable or class declarations we like, and they will be available as part of the package. In our example, if the `ecommerce/__init__.py` file contained this line: `from .database import db`, we can then access the `db` attribute from `main.py` or any other file using this import: `from ecommerce import db`.
* All module-level code is executed immediately at the time it is imported. However, if it is inside a method or function, the function will be created, but its internal code will not be executed until the function is called. We should always put our startup code in a function (conventionally,
  called main) and only execute that function when we know we are running the module as a script, but not when our code is being imported from a different script.
* Technically, all methods and attributes on a class are publicly available. By convention, we should prefix an attribute or method with an underscore character `_`. It means that *"this is an internal variable, think three times before accessing it directly"*.
* Name mangling: Prefixing double underscore `"__"` before a method or property means that the method or property can still be called by outside objects, but require extra work and is strong indicator that you demand that your attribute remains private.
* Inheritance: All python classes are subclasses of the special class named `object`.
* Abstract base classes: They define a set of methods and properties that a class must implement in order to be considered a duck-type instance of that class. The class can extend the abstract base class itself in order to be used as an instance of that class, but it must supply all the appropriate methods. Most of the abstract base classes that exist in the Python Standard Library live in the collections module.
* By marking a method or property as being abstract, you are stating that any subclass of this class must implement that method or supply that property in order to be considered a proper member of the class.
* Exceptions: All exceptions inherit from built-in class called `BaseException`. If we have a function that calls another function that raises an exception, nothing will be executed in the first function after the point where the second function was called. We handle exceptions by wrapping any code that might throw one (whether it is exception code itself, or a call to any function or method that may have an exception raised inside it) inside a `try...except clause`. The `try` clause wraps any code that might throw an exception. The `except` clause is then back on the same indentation level as the `try` line. Any code to handle the exception is indented after the `except`
  clause.
* Most exceptions are subclasses of the `Exception` class. `Exception` itself inherits from a class called `BaseException`.  All exceptions must extend the `BaseException` class or one of its subclasses. There are two key exceptions, `SystemExit` and `KeyboardInterrupt`, that derive directly from `BaseException` instead of `Exception`. The `SystemExit` exception is raised whenever the program exits naturally, typically because we called the `sys.exit` function somewhere in our code. The exception is designed to allow us to clean up code before the
  program ultimately exits, so we generally don't need to handle it explicitly (because cleanup code happens inside a `finally` clause).
* When we use the except: clause without specifying any type of exception, it will catch all subclasses of `BaseException`; which is to say, it will catch all exceptions, including the two special ones. Since we almost always want these to get special treatment, it is unwise to use the except: statement without arguments. If you want to catch all exceptions other than `SystemExit` and `KeyboardInterrupt`, explicitly catch `Exception`.
* The `Exception.__init__` method is designed to accept any arguments and store them as tuple in an attribute named `args`. This makes exceptions easier to define without needing to override `__init__`.
* Reasons to have custom exceptions: Add info to the exception, log it, to give info the the programmer about the behaviour of a library in helping debugging.
* Python gives us the property keyword to make methods look like attributes. We can therefore write our code to use direct member access, and if we unexpectedly need to alter the implementation to do some calculation when getting or setting that attribute's value, we can do so without changing the interface.
* Decorator: `@property` applies `property` function as a decorator, and is equivalent to `property()` syntax. It defines the `getter` function.
* In Python, data, properties, and methods are all attributes on a class. The fact that a method is callable does not distinguish it from other types of attributes.

## Python Data Structure

* It is not possible to set any attributes on an object that was instantiated directly. It is to save memory as allowing Python to have arbitrary attribute will take a certain amount of memory to track of what attributes each object has, for storing both attribute name and its value. Even without any attributes, memory has to be allocated for potential new attributes.
* Tuples: can store specific number of other objects in __order__. They are __immutable__. They are used to store data, behaviour cannot be stored in a tuple. The primary purpose of a tuple is to aggregate different pieces of data together into one container.
* Named Tuples: If we do not need to add behaviour to an object, and it is known in advance what attributes need to be stored, __named tuple__ can be used. `namedtuple` constructor accepts two arguments. First is identifier for the named tuple, and second is a string of space-separated attributes that the named tuple can have. Named tuples are immutable too.
* Dictionaries: They allow to map objects directly to other objects. They are extremely efficient in looking up a value, given a specific key. Using `get` method in dictionaries, it can accept a key as first parameter, and an optional default value if the key doesn't exist. For even more control, we can use the `setdefault` method. The order is not preserved in the dictionary. They are unsorted. Anything unmutable can be used as dictionary key. Dictionaries are used in cases where each key represent different instances of similar objects. They are also used where each key represents some aspect of a single structure.
* Defaultdict: The `defaultdict` accepts a function as its constructor. Whenever a key is accessed that is not already in the dictionary, it calls that function, to create a default value.
* When we have a built-in container object that we want to add functionality to, we have two options: i. Create a new object, which holds that container as an attribute(composition). ii. Subclass the built-in object and add or adapt methods on it to do what we want(inheritance).
* 

